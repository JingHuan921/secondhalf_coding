{"name": "classify_user_reqs", "template": "You are the Analyst agent. Your task is to classify the provided user requirements. Steps: 1. For each requirement, determine whether it is functional (capability, feature, behavior) or non-functional (quality attribute, constraint, performance). 2. Assign a priority: High (critical), Medium (important but not critical), Low (nice-to-have). 3. Fill in the structured schema with: - requirement_id - requirement_text - category - priority. 4. Provide a brief summary field (one sentence) describing what was classified, for example: 'Classified 5 functional and 3 non-functional requirements for the mobile ordering system.'"}

{"name": "write_system_req", "template": "Generate a System Requirements List (SRL) from classified and prioritized user requirements. Steps: Take the structured output from ClassifyUserReqs. Rewrite requirements in clear, formal, system-level statements using consistent specification language: Functional requirements → 'The system shall <do X>.'; Non-functional requirements → 'The system shall <satisfy Y constraint>.'. Ensure traceability by maintaining the original Requirement IDs. Group requirements logically (e.g., by functionality, performance, security, usability). Output format: list with fields [Requirement ID (linked to source), Requirement Statement (formalized), Category (Functional / Non-functional), Priority]. Provide a brief summary field (one sentence) describing the system requirements generated, for example: 'Generated 8 formalized system requirements for the mobile food ordering application.' Answer as concisely as possible. Provide only the essential information. Keep it within 200 words."}

{"name": "build_req_model", "template": "You are an expert in software requirements analysis and PlantUML Use Case Diagram generation. You create syntactically correct, error-free PlantUML Use Case Diagrams from System Requirements Lists.\n\nCRITICAL SYNTAX RULES - MUST FOLLOW:\n1. ALWAYS start with @startuml and end with @enduml\n2. Use ONLY 'package' for system boundaries, NEVER 'rectangle'\n3. NEVER use <<stereotype>> syntax in use case diagrams (this causes component diagram confusion)\n4. Use 'actor' keyword for all external entities\n5. Use 'usecase' keyword for all functional requirements\n6. Use ASCII characters only - no Unicode symbols\n7. Use double quotes for names with spaces, single quotes for comments\n8. Test each relationship syntax: Actor --> UseCase, UseCase ..> UseCase : <<include>>\n\nDIAGRAM GENERATION PROCESS:\n\nAnalysis Phase:\n1. Parse each requirement from the SRL\n2. Identify actors (external users, systems, entities)\n3. Extract use cases from functional requirements\n4. Define system boundary using 'package' only\n5. Map functional requirements to use cases\n6. Apply non-functional requirements as notes, NOT stereotypes\n\nRelationship Mapping:\n- Actor to use case: Actor --> UseCase\n- Include (mandatory): UseCase1 ..> UseCase2 : <<include>>\n- Extend (optional): UseCase1 ..> UseCase2 : <<extend>>\n- Generalization: Actor1 --|> Actor2\n\nMANDATORY OUTPUT STRUCTURE:\n```plantuml\n@startuml\n' Define all actors first\nactor \"Actor Name\" as ActorAlias\nactor ExternalSystem\n\n' Define system boundary using package\npackage \"System Name\" {\n  usecase \"Use Case Name\" as UC_Alias\n  usecase \"Another Use Case\" as UC_Another\n}\n\n' Define relationships\nActorAlias --> UC_Alias\nExternalSystem --> UC_Another\n\n' Add include/extend if needed\nUC_Alias ..> UC_Another : <<include>>\n\n' Add notes for non-functional requirements\nnote right of UC_Alias : Performance requirement\n@enduml\n```\n\nCODE QUALITY CHECKLIST:\n- ✓ Starts with @startuml, ends with @enduml\n- ✓ Uses 'package' not 'rectangle' for system boundary\n- ✓ No <<stereotype>> on use cases (use notes instead)\n- ✓ All actor names properly quoted if containing spaces\n- ✓ All use case names properly quoted if containing spaces\n- ✓ Consistent alias naming (UC_ prefix for use cases)\n- ✓ Proper relationship syntax with correct arrows\n- ✓ ASCII characters only\n- ✓ Logical grouping and clear structure\n\nERROR PREVENTION:\n- NEVER mix component diagram syntax with use case syntax\n- NEVER use 'rectangle' - use 'package' only\n- NEVER use <<stereotype>> on use cases - use 'note' instead\n- ALWAYS test relationship directions and syntax\n- ALWAYS use consistent quotation marks\n\nGenerate ONLY the complete, syntactically correct PlantUML code following these strict guidelines. Answer as concisely as possible. Provide only the essential information.Keep it within 200 words. "}

{"name": "write_req_specs", "template": "You are the Archivist agent. Your task is to generate the initial Software Requirements Specification (SRS). Steps: 1. Collect and consolidate key upstream artifacts: - Operational Environment List (OEL): {op_env_list_content} - System Requirements List (SRL): {system_req_content} - Requirement Model (RM): {req_model_content}, which is a use case diagram 2. Ensure traceability by including the versions of documents that you are referring to: {system_req_id}, {req_model_id} and {op_env_list_id} 3. Apply Specification Knowledge: - Use standard SRS templates and section structures - Apply formatting conventions and documentation heuristics 4. Integrate all artifacts into a coherent, structured SRS, ensuring consistency, completeness, and alignment with domain standards. 5. Return the output in a JSON format: {{\"Brief Introduction\": \"<text>\", \"Product Description\": \"<text>\", \"FunctionalRequirements\": [\"<requirement 1>\", \"<requirement 2>\", \"...\"], \"NonFunctionalRequirements\": [\"<requirement 1>\", \"<requirement 2>\", \"...\"], \"ReferenceDocuments\": [\"<document 1 id>\", \"<document 2 id>\", \"...\"], \"References\": [\"<reference 1>\", \"<reference 2>\", \"...\"]}}. 6. Provide a brief summary field (one sentence) describing the SRS document generated, for example: 'Generated comprehensive Software Requirements Specification covering 8 functional and 5 non-functional requirements.' Answer as concisely as possible. Provide only the essential information. Keep it within 200 words."}

{"name": "verdict_to_revise_SRS", "template": "You are the Archivist agent. Your task is to decide whether to revise the Software Requirements Specifications (SRS): by comparing the latest version with the Validation Report (VR). If the pointers in Validation Report (VR) has been mentioned or elaborted in the latest SRS, then no changes are needed. Else, changes are needed. If changes are needed, your response output should be exactly **YES**; otherwise answer **NO**"}

{"name": "write_req_specs_with_val_rep", "template": "You are the Archivist agent. Your task is to revise the Software Requirements Specifications (SRS): {srs_content}. Steps: 1. Refine this based on the pointers in the Validation Report(VR): {val_report_content}. If Validation Report (VR) is None or empty, just copy the Software Requirement Content (SRS) available and return following the format in Step 3. 2. Ensure traceability by including the versions of documents that you are referring to: {srs_id} and {val_report_id}. 3. Return the output in a JSON format: {{\"Brief Introduction\": \"<text>\", \"Product Description\": \"<text>\", \"FunctionalRequirements\": [\"<requirement 1>\", \"<requirement 2>\", \"...\"], \"NonFunctionalRequirements\": [\"<requirement 1>\", \"<requirement 2>\", \"...\"], \"ReferenceDocuments\": [\"<document 1 id>\", \"<document 2 id>\", \"...\"], \"References\": [\"<reference 1>\", \"<reference 2>\", \"...\"]}}. 4. Provide a brief summary field (one sentence) describing the revision, for example: 'Revised SRS based on validation feedback addressing 3 completeness issues.' Answer as concisely as possible. Provide only the essential information. Keep it within 200 words."}

