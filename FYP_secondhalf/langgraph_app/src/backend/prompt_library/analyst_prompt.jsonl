{"name": "classify_user_reqs", "template": "You are the Analyst agent. Your task is to classify the provided user requirements. Steps: 1. For each requirement, determine whether it is functional (capability, feature, behavior) or non-functional (quality attribute, constraint, performance). 2. Assign a priority: High (critical), Medium (important but not critical), Low (nice-to-have). 3. Fill in the structured schema with: - requirement_id - requirement_text - category - priority"}

{"name": "write_system_req", "template": "Generate a System Requirements List (SRL) from classified and prioritized user requirements. Steps: Take the structured output from ClassifyUserReqs. Rewrite requirements in clear, formal, system-level statements using consistent specification language: Functional requirements → 'The system shall <do X>.'; Non-functional requirements → 'The system shall <satisfy Y constraint>.'. Ensure traceability by maintaining the original Requirement IDs. Group requirements logically (e.g., by functionality, performance, security, usability). Output format: list with fields [Requirement ID (linked to source), Requirement Statement (formalized), Category (Functional / Non-functional), Priority]."}

{"name": "build_req_model", "template": "You are an expert in software requirements analysis and UML diagram generation. You create high-quality PlantUML Use Case Diagrams from System Requirements Lists. Construct a PlantUML Use Case Diagram from the provided System Requirements List (SRL). Follow these steps:\n\nAnalysis Phase:\n1. Parse each requirement from the SRL\n2. Identify actors (external users, systems, or entities)\n3. Extract use cases from functional requirements (user interactions with the system)\n4. Define the system boundary\n5. Map functional requirements to use cases\n6. Apply non-functional requirements as UML notes or stereotypes\n\nRelationship Mapping:\n- Create associations between actors and use cases\n- Identify include relationships (mandatory sub-processes)\n- Identify extend relationships (optional variations)\n- Ensure proper dependency flows\n\nOutput Requirements:\nGenerate clean PlantUML code with the following structure:\n- Start with @startuml\n- Define all actors using 'actor' keyword\n- Define system boundary using 'rectangle' or 'package'\n- List all use cases within the system boundary\n- Establish actor-to-use-case associations using '-->' notation\n- Add include/extend relationships where applicable\n- Use clear, descriptive names without special Unicode characters\n- End with @enduml\n\nCode Quality Standards:\n- Use ASCII characters only (avoid Unicode symbols like arrows, special quotes)\n- Follow consistent naming conventions\n- Add comments using single quotes for clarity\n- Group related elements logically\n- Ensure all relationships are properly connected\n\nExample Structure:\n@startuml\nactor ActorName\nrectangle \"System Name\" {\n  usecase \"Use Case Name\" as UC_Name\n}\nActorName --> UC_Name\n@enduml\n\nGenerate the complete PlantUML diagram code following these guidelines."}

{"name": "write_req_specs", "template": "You are the Archivist agent. Your task is to generate the initial Software Requirements Specification (SRS). Steps: 1. Collect and consolidate key upstream artifacts: - Operational Environment List (OEL): {op_env_list_content} - System Requirements List (SRL): {system_req_content} - Requirement Model (RM): {req_model_content}, which is a use case diagram 2. Ensure traceability by including the versions of documents that you are referring to: {system_req_id}, {req_model_id} and {op_env_list_id} 3. Apply Specification Knowledge: - Use standard SRS templates and section structures - Apply formatting conventions and documentation heuristics 4. Integrate all artifacts into a coherent, structured SRS, ensuring consistency, completeness, and alignment with domain standards. 5. Return the output in a JSON format: {{\"Brief Introduction\": \"<text>\", \"Product Description\": \"<text>\", \"FunctionalRequirements\": [\"<requirement 1>\", \"<requirement 2>\", \"...\"], \"NonFunctionalRequirements\": [\"<requirement 1>\", \"<requirement 2>\", \"...\"], \"ReferenceDocuments\": [\"<document 1 id>\", \"<document 2 id>\", \"...\"], \"References\": [\"<reference 1>\", \"<reference 2>\", \"...\"]}}"}

{"name": "verdict_to_revise_SRS", "template": "You are the Archivist agent. Your task is to decide whether to revise the Software Requirements Specifications (SRS): by comparing the latest version with the Validation Report (VR). If the pointers in Validation Report (VR) has been mentioned or elaborted in the latest SRS, then no changes are needed. Else, changes are needed. If changes are needed, your response output should be exactly **YES**; otherwise answer **NO**"}

{"name": "write_req_specs_with_val_rep", "template": "You are the Archivist agent. Your task is to revise the Software Requirements Specifications (SRS): {srs_content}. Steps: 1. Refine this based on the pointers in the Validation Report(VR): {val_report_content}. 2. Ensure traceability by including the versions of documents that you are referring to: {srs_id} and {val_report_id}. 3. Return the output in a JSON format: {{\"Brief Introduction\": \"<text>\", \"Product Description\": \"<text>\", \"FunctionalRequirements\": [\"<requirement 1>\", \"<requirement 2>\", \"...\"], \"NonFunctionalRequirements\": [\"<requirement 1>\", \"<requirement 2>\", \"...\"], \"ReferenceDocuments\": [\"<document 1 id>\", \"<document 2 id>\", \"...\"], \"References\": [\"<reference 1>\", \"<reference 2>\", \"...\"]}}"}

